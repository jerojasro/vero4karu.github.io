<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: django | Cansada de ser feliz]]></title>
  <link href="http://blog.vero4ka.info/blog/categories/django/atom.xml" rel="self"/>
  <link href="http://blog.vero4ka.info/"/>
  <updated>2017-01-07T11:31:34-05:00</updated>
  <id>http://blog.vero4ka.info/</id>
  <author>
    <name><![CDATA[vero4ka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cómo pasar variable desde una vista a formulario en Django]]></title>
    <link href="http://blog.vero4ka.info/blog/2016/10/21/como-pasar-variable-desde-una-vista-a-formulario-en-django/"/>
    <updated>2016-10-21T14:07:56-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2016/10/21/como-pasar-variable-desde-una-vista-a-formulario-en-django</id>
    <content type="html"><![CDATA[<pre><code class="python views.py">class MyCreateView(CreateView):
    model = MyModel
    template_name = 'myapp/my_form.html'
    form_class = MyForm

    def get_form_kwargs(self):
        kwargs = super(MyCreateView, self).get_form_kwargs()

        # La variable que queremos pasar al formulario
        kwargs.update({'current_user': self.request.user})

        return kwargs
</code></pre>

<pre><code class="python forms.py">class MyForm(forms.ModelForm):

    def __init__(self, *args, **kwargs):
        # Recibir la variable y borrarla del listado de argumentos.
        current_user = kwargs.pop('current_user')

        super(MyForm, self).__init__(*args, **kwargs)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Múltiples bases de datos en Django]]></title>
    <link href="http://blog.vero4ka.info/blog/2016/08/31/multiples-bases-de-datos-en-django/"/>
    <updated>2016-08-31T11:15:01-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2016/08/31/multiples-bases-de-datos-en-django</id>
    <content type="html"><![CDATA[<p>Tenemos dos tablas con esquemas iguales dos en bases de datos diferentes: <code>production</code> y <code>history</code>.</p>

<pre><code class="python settings.py">DATABASE_ROUTERS = ['routers.HistoricRouter']

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'HOST': 'localhost',
        'NAME': 'production',
        'USER': 'secret',
        'PASSWORD': 'secret',
    },
    'historical': {
        'ENGINE': 'django.db.backends.postgresql',
        'HOST': 'localhost',
        'NAME': 'history',
        'USER': 'secret',
        'PASSWORD': 'secret',
    }
}
</code></pre>

<p>Escribimos un router para definir a qué base de datos hacer la petición:</p>

<pre><code class="python routers.py">class HistoricRouter(object):
    """
    A router to control all database operations on models in the historic application.
    """
    def db_for_read(self, model, **hints):
        """
        Attempts to read historic models go to historical.
        """
        if model._meta.app_label == 'historic':
            return 'historical'
        return None

    def db_for_write(self, model, **hints):
        """
        Attempts to write historic models go to historical.
        """
        if model._meta.app_label == 'historic':
            return 'historical'
        return None

    def allow_relation(self, obj1, obj2, **hints):
        """
        Allow relations if a model in the historic app is involved.
        """
        if obj1._meta.app_label == 'historic' or \
            obj2._meta.app_label == 'historic':
            return True
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        """
        Make sure the historic app only appears in the 'historical' database.
        """
        if app_label == 'historic':
            return db == 'historical'
        return None
</code></pre>

<p>En nuestros modelos especificamos <code>app_label</code> para referirnos a la base de datos distinta a <code>default</code>:</p>

<pre><code class="python models.py">class Author(models.Model):

    class Meta:
        db_table = 'authors'

class AbstractBook(models.Model):
    author = models.ForeignKey('books.Author', related_name='books')
    created_at = models.DateTimeField()

    class Meta:
        unmanaged = True
        abstract = True

class Book(Book):

    class Meta:
        db_table = 'books'

class HistoricBook(Book):

    class Meta:
        unmanaged = True
        db_table = 'books'
        app_label = 'historic'
</code></pre>

<p>La petición <code>Book.objects.all()</code> va a traer libros de la base de datos <code>production</code> y <code>HistoricBook.objects.all()</code> - de la base de datos <code>history</code>.</p>

<p>Modificando <code>allow_relation</code> en nuestro router, podemos permitir llaves foráneas entre modelos de diferentes bases de datos:</p>

<pre><code class="python">    def allow_relation(self, obj1, obj2, **hints):
        return True
</code></pre>

<p>Enlaces:</p>

<ul>
<li><a href="https://docs.djangoproject.com/en/1.10/topics/db/multi-db/#cross-database-relations">Django: Cross-database relations</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flask for Django developers]]></title>
    <link href="http://blog.vero4ka.info/blog/2016/07/22/flask-for-django-developers/"/>
    <updated>2016-07-22T07:35:02-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2016/07/22/flask-for-django-developers</id>
    <content type="html"><![CDATA[<ol>
<li>Aplicación básica</li>
<li>Blueprints</li>
<li>URLs</li>
<li>Vistas</li>
<li>Plantillas (Jinja2)</li>
<li>Procesadores de contexto</li>
<li>Modelos (SQLAlchemy, CRUD)</li>
<li>Formularios</li>
<li>Autenticación</li>
<li>Múltiples idiomas</li>
<li>Mensajes (flash)</li>
<li>Cache</li>
</ol>


<iframe src="//slides.com/vero4ka/flask-para-desarrolladorres-de-django/embed?style=light" width="576" height="420" scrolling="no" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>


<ul>
<li>Slides: <a href="http://slides.com/vero4ka/flask-para-desarrolladorres-de-django/">http://slides.com/vero4ka/flask-para-desarrolladorres-de-django/</a></li>
<li>Examples: <a href="https://github.com/vero4karu/flask-examples">https://github.com/vero4karu/flask-examples</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pruebas para formularios en Django]]></title>
    <link href="http://blog.vero4ka.info/blog/2015/09/30/pruebas-para-formularios-en-django/"/>
    <updated>2015-09-30T04:49:19-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2015/09/30/pruebas-para-formularios-en-django</id>
    <content type="html"><![CDATA[<p>En esta entrada de blog quiero compartir la forma en la que escribo ruebas para formularios en un proyecto de Django.</p>

<p>Primero vamos a instalar los paquetes necesarios:</p>

<p>{% codeblock %}
$ pip install django-webtest
$ pip install factory-boy
{% endcodeblock %}</p>

<p><a href="http://webtest.pythonpaste.org/en/latest/WebTest">WebTest</a> es una biblioteca que nos ayuda a escribir pruebas para las aplicaciones wsgi. Es mucho más poderosa comparando con <code>django.test.Client</code> que viene con Django.</p>

<p>En el archivo de configuración especificamos que vamos a usar la base de datos SQLite para correr nuestras pruebas:</p>

<p>{% codeblock test_settings.py lang:python %}
DATABASES = {
    &lsquo;default&rsquo;: {
        &lsquo;ENGINE&rsquo;: &lsquo;django.db.backends.sqlite3&rsquo;,
    }
}
{% endcodeblock %}</p>

<p>Suponemos que queremos escribir una prueba unitaria para una vista que crea un objeto del modelo <code>Event</code>:</p>

<p>{% codeblock models.py lang:python %}
class Event(models.Model):
    title = models.CharField(max_length=500)
    start_date = models.DateTimeField()
    end_date = models.DateTimeField(blank=True, null=True)
    people = models.ManyToManyField(&lsquo;history.Person&rsquo;, blank=True, related_name=&lsquo;events&rsquo;)</p>

<p>class Person(models.Model):
    name = models.CharField(max_length=255)
{% endcodeblock %}</p>

<p>Aquí está la vista que maneja el formulario para crear un evento:</p>

<p>{% codeblock views.py lang:python %}</p>

<p>class EventCreateView(LoginRequiredMixin, CreateView):
    model = Event
    form_class = EventForm
    success_url = reverse_lazy(&lsquo;history:timeline&rsquo;)
{% endcodeblock %}</p>

<p>Ahora escribimos nuestra prueba. Vamos a extender la clase <code>django_webtest.WebTest</code>, que en su lugar extiende <code>django.test.TestCase</code> de Django, y crear a un usuario:</p>

<p>{% codeblock tests.py lang:python %}
from django_webtest import WebTest</p>

<p>class HistoryViewsTests(WebTest):
    def setUp(self):
        self.superuser = get_user_model().objects.create_superuser(
            email=&lsquo;<a href="&#109;&#97;&#x69;&#108;&#x74;&#x6f;&#58;&#x73;&#x75;&#x70;&#101;&#114;&#117;&#x73;&#x65;&#114;&#64;&#101;&#120;&#97;&#x6d;&#112;&#x6c;&#101;&#46;&#99;&#x6f;&#109;">&#115;&#x75;&#x70;&#101;&#114;&#117;&#115;&#x65;&#x72;&#64;&#x65;&#120;&#x61;&#x6d;&#x70;&#x6c;&#x65;&#46;&#99;&#x6f;&#109;</a>&rsquo;,
            username=&lsquo;superuser&rsquo;,
            password=&lsquo;secret&rsquo;,
        )
        super(HistoryViewsTests, self).setUp()</p>

<pre><code>def test_create_event(self):
    # código para nuestra prueba
</code></pre>

<p>{% endcodeblock %}</p>

<p>Ahora podemos probar que cuando un usuario trata de acceder nuestra página, se redirige al formulario de acceso (el códigos de estado HTTP es 302):</p>

<p>{% codeblock lang:python %}
url = reverse(&lsquo;history:event_create&rsquo;)
self.app.get(url, status=302)
{% endcodeblock %}</p>

<p>Ahora vamos a acceder la vista como superusuario:</p>

<p>{% codeblock lang:python %}
response = self.app.get(url, user=self.superuser, status=200)
{% endcodeblock %}</p>

<p>Como tenemos solo un formulario en la página, podemos obtenerlo por una de tres formas: por el atributo <code>.form</code>: <code>response.form</code>, por índice <code>response.forms[0]</code> o por <code>id</code> del formulario (artibuto HTML)<code>response.forms['event_form']</code>.</p>

<p>Para facilitar la depuración de nuestras pruebas, podemos pedir a mostrar el <code>response</code> en navegador predeterminado:</p>

<p>{% codeblock lang:python %}
response.showbrowser()
{% endcodeblock %}</p>

<p>Ahora podemos diligenciar nuestro formulario con los datos de prueba:</p>

<p>{% codeblock tests.py lang:python %}
class HistoryViewsTests(WebTest):
    # &hellip;</p>

<pre><code>def test_create_event(self):
    person1, person2, person3 = PersonFactory.create_batch(3)
    response = self.app.get(url, user=self.superuser, status=200)

    self.assertFalse(Event.objects.exists())

    form = response.forms['event_form']
    form['title'] = u'Título del evento'
    form['start_date'] = datetime.datetime.now()
    form['people'] = [person1.id, person2.id]
    form.submit().follow()

    self.assertEqual(Event.objects.count(), 1)

    event = Event.objects.first()
    self.assertEqual(event.title, u'Título del evento')

    people = event.people.all()
    self.assertIn(person1, people)
    self.assertIn(person2, people)
    self.assertNotIn(person3, people)
</code></pre>

<p>{% endcodeblock %}</p>

<p>Para generar objetos del modelo <code>Person</code> usamos la biblioteca <a href="http://factoryboy.readthedocs.org/">Factory Boy</a>:</p>

<p>{% codeblock factories.py lang:python %}
from ..models import Person</p>

<p>import factory
import factory.fuzzy</p>

<p>class PersonFactory(factory.django.DjangoModelFactory):
    name = factory.fuzzy.FuzzyText(length=50)</p>

<pre><code>class Meta:
    model = Person
</code></pre>

<p>{% endcodeblock %}</p>

<p>Así podemos acceder los opciones de una selección o selección múltiple:</p>

<p>{% codeblock lang:pycon %}</p>

<blockquote><blockquote><blockquote><p>print form[&lsquo;people&rsquo;].options
[(u'1', False, u'GLUZLvZfyjdZEmjNtnAJvsIVljodQjZpzLRDKrqJtYGiDLmSrN'), (u'2', False, u'vOxDBbmLaUXxJkJzcqYgLQpBieSoLtXJcpHCEPUpYUIzybhsAh'), (u'3', False, u'tfXSXCTIQICDwVPYvxZGSXgclFTnHbeYSQaMntxJNcgUJjzAwX')]
form[&lsquo;people&rsquo;] = [person1.id, person2.id]
print form[&lsquo;people&rsquo;].value
[u'1', u'2']
{% endcodeblock %}</p></blockquote></blockquote></blockquote>

<p>Ahora corremos nuestras pruebas y voilà:</p>

<p>{% codeblock %}
$ ./manage.py test
Creating test database for alias &lsquo;default&rsquo;&hellip;</p>

<h2>..</h2>

<p>Ran 1 test in 0.463s</p>

<p>OK
Destroying test database for alias &lsquo;default&rsquo;&hellip;
{% endcodeblock %}</p>

<p>Enlaces:</p>

<ul>
<li><a href="https://github.com/django-webtest/django-webtest">WebTest</a></li>
<li><a href="http://webtest.pythonpaste.org/en/latest/forms.html">Manejo de formularios con WebTest</a></li>
<li><a href="http://factoryboy.readthedocs.org/">Factory Boy</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to raise a form invalid event inside form_valid method of a FormView]]></title>
    <link href="http://blog.vero4ka.info/blog/2015/03/01/how-to-raise-a-form-invalid-event-inside-form-valid-method-of-a-formview/"/>
    <updated>2015-03-01T19:35:52-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2015/03/01/how-to-raise-a-form-invalid-event-inside-form-valid-method-of-a-formview</id>
    <content type="html"><![CDATA[<p>How to raise form invalid inside <code>form_valid</code> method of a <code>FormView</code> (<code>CreateView</code>/<code>UpdateView</code>) and add an error message to <code>non_field_errors</code>:</p>

<p>{% gist 3b62a13bdce7fe4178ac %}</p>
]]></content>
  </entry>
  
</feed>
