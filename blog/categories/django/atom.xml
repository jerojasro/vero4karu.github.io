<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: django | Cansada de ser feliz]]></title>
  <link href="http://blog.vero4ka.info/blog/categories/django/atom.xml" rel="self"/>
  <link href="http://blog.vero4ka.info/"/>
  <updated>2017-03-06T21:53:06-05:00</updated>
  <id>http://blog.vero4ka.info/</id>
  <author>
    <name><![CDATA[vero4ka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Cómo desplegar un proyecto de Django con uWSGI + nginx + supervisor]]></title>
    <link href="http://blog.vero4ka.info/blog/2017/01/16/como-desplegar-un-proyecto-de-django-con-uwsgi-plus-nginx-plus-supervisor/"/>
    <updated>2017-01-16T17:39:09-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2017/01/16/como-desplegar-un-proyecto-de-django-con-uwsgi-plus-nginx-plus-supervisor</id>
    <content type="html"><![CDATA[<p>Suponemos que tenemos <a href="https://github.com/vero4karu/sitp_scraper">un proyecto</a> de Django y queremos desplegarlo en un servidor con un sistema operativo Linux.</p>

<p>La idea es que nuestro servidor web va a usar una interfaz (WSGI) para &ldquo;hablar&rdquo; con nuestra aplicación de Django. Esa interfaz va a correr la aplicación, pasarle las peticiones de usuario y devolver la respuesta. WSGI (Web Server Gateway Interface) es un estándar y uWSGI es una de sus implementaciones que vamos a usar:</p>

<pre><code>Usuario &lt;-&gt; Servidow web &lt;-&gt; Socket &lt;-&gt; uWSGI &lt;-&gt; Django
</code></pre>

<!-- more -->


<p>Decimos que el código del proyecto está en la carpeta <code>/home/deploy/sitp_scraper</code>. Primero creamos el entorno virtual e instalamos las librerías de Python proyecto (en éste ejemplo usamos <a href="https://virtualenvwrapper.readthedocs.io/en/latest/">virtualenvwrapper</a>):</p>

<pre><code>mkvirtualenv stip_scraper
pip install -r requitements.txt
</code></pre>

<p>Instalamos uWSGI:</p>

<pre><code>pip install uwsgi
</code></pre>

<p>Verificamos si podemos correr nuestro proyecto si problema:</p>

<pre><code>./manage.py runserver 0.0.0.0:8000
</code></pre>

<p>Ahora probamos correrlo usando uWSGI:</p>

<pre><code>uwsgi --http :8000 --module stip_scraper.wsgi
</code></pre>

<p>Instalamos <a href="https://nginx.org/en/">nginx</a>:</p>

<pre><code>sudo apt-get install nginx
sudo /etc/init.d/nginx start 
</code></pre>

<p>Si al visitar <code>nuestroservidor.com:80</code> vemos el mensaje &ldquo;Welcome to nginx&rdquo;, podemos concluir que nginx funciona de la forma correcta.</p>

<p>Configuramos nginx <code>sitp_scraper_nginx.conf</code>:</p>

<pre><code class="nginx">upstream django {
    server unix:///tmp/sitp_scraper.sock;
}

server {
    listen 80;
    listen [::]:80;
    server_name  nuestroservidor.com;  # Nuestro dominio o dirección IP
    charset      utf-8;

    client_max_body_size 10M;  # Tamaño máximo de archivos que podrémos subir al servidor

    location /media  {
        # MEDIA_ROOT de nuestro proyecto de Django
        alias /home/deploy/sitp_scraper/media;
    }

    location /static {
        # STATIC_ROOT de nuestro proyecto de Django
        alias /home/deploy/sitp_scraper/static;

    }

    location / {
        uwsgi_pass  django;
        include     /home/deploy/sitp_scraper/uwsgi_params;
    }
}
</code></pre>

<p>El archivo <code>uwsgi_params</code> se puede descargar aquí: <a href="https://github.com/nginx/nginx/blob/master/conf/uwsgi_params">github.com/nginx/nginx/blob/master/conf/uwsgi_params</a></p>

<p>Creamos en la carpeta <code>/etc/nginx/sites-enabled</code> un enlace hacía nuestra configuración para que nginx pueda verla:</p>

<pre><code>sudo ln -s ~/path/to/your/sitp_scraper_nginx.conf /etc/nginx/sites-enabled/
</code></pre>

<p>Verificamos si nuestra configuración está bien:</p>

<pre><code>nginx -t
</code></pre>

<p>y reiniciamos nginx:</p>

<pre><code>sudo /etc/init.d/nginx restart
</code></pre>

<p>Ahora creamos un archivo <code>sitp_scraper_uwsgi.ini</code> para guardar las opciones que vamos a pasar a uWSGI:</p>

<pre><code>[uwsgi]
# Django-related settings
chdir           = /home/deploy/sitp_scraper
module          = sitp_scraper.wsgi
home            = /home/deploy/.virtualenvs/sitp_scraper

# Process-related settings
master          = true
processes       = 10

# The socket (use the full path to be safe)
socket          = /tmp/sitp_scraper.sock
chmod-socket    = 664
uid             = www-data
gid             = www-data

# Clear environment on exit
vacuum          = true
</code></pre>

<p>Agregamos nuestro usuario de Linux al grupo <code>www-data</code> (para no tener problemas con permisos) y verificamos que todo funcione bien:</p>

<pre><code>uwsgi --ini sitp_scraper_uwsgi.ini
</code></pre>

<p>Podemos ver que se creó un archvo <code>/tmp/sitp_scraper.sock</code>:</p>

<pre><code>ll /tmp/sitp_scraper.sock
srw-rw-r-- 1 www-data www-data 0 Jan 15 20:46 /tmp/sitp_scraper.sock
</code></pre>

<p>Ahora instalamos supervisor:</p>

<pre><code>apt-get install supervisor
service supervisor start
</code></pre>

<p>y creamos un archivo de configuración <code>/etc/supervisor/conf.d/sitp_scraper.conf</code></p>

<pre><code>[program:uwsgi]
user            = www-data
command = /home/deploy/.virtualenvs/sitp_scraper/bin/uwsgi --ini=/home/deploy/sitp_scraper/sitp_scraper_uwsgi.ini
autostart       = true
autorestart     = true
stderr_logfile  = /tmp/uwsgi_err.log
stdout_logfile  = /tmp/uwsgi.log
stopsignal=INT
</code></pre>

<p>Reiniciamos supervisor:</p>

<pre><code>$ supervisorctl  
uwsgi                            RUNNING   pid 2762, uptime 1 day, 2:39:40
supervisor&gt; restart uwsgi
</code></pre>

<p>Voilà: <code>nuestroservidor.com:80</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cómo pasar variable desde una vista a formulario en Django]]></title>
    <link href="http://blog.vero4ka.info/blog/2016/10/21/como-pasar-variable-desde-una-vista-a-formulario-en-django/"/>
    <updated>2016-10-21T14:07:56-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2016/10/21/como-pasar-variable-desde-una-vista-a-formulario-en-django</id>
    <content type="html"><![CDATA[<pre><code class="python views.py">class MyCreateView(CreateView):
    model = MyModel
    template_name = 'myapp/my_form.html'
    form_class = MyForm

    def get_form_kwargs(self):
        kwargs = super(MyCreateView, self).get_form_kwargs()

        # La variable que queremos pasar al formulario
        kwargs.update({'current_user': self.request.user})

        return kwargs
</code></pre>

<pre><code class="python forms.py">class MyForm(forms.ModelForm):

    def __init__(self, *args, **kwargs):
        # Recibir la variable y borrarla del listado de argumentos.
        current_user = kwargs.pop('current_user')

        super(MyForm, self).__init__(*args, **kwargs)
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Múltiples bases de datos en Django]]></title>
    <link href="http://blog.vero4ka.info/blog/2016/08/31/multiples-bases-de-datos-en-django/"/>
    <updated>2016-08-31T11:15:01-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2016/08/31/multiples-bases-de-datos-en-django</id>
    <content type="html"><![CDATA[<p>Tenemos dos tablas con esquemas iguales dos en bases de datos diferentes: <code>production</code> y <code>history</code>.</p>

<pre><code class="python settings.py">DATABASE_ROUTERS = ['routers.HistoricRouter']

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'HOST': 'localhost',
        'NAME': 'production',
        'USER': 'secret',
        'PASSWORD': 'secret',
    },
    'historical': {
        'ENGINE': 'django.db.backends.postgresql',
        'HOST': 'localhost',
        'NAME': 'history',
        'USER': 'secret',
        'PASSWORD': 'secret',
    }
}
</code></pre>

<p>Escribimos un router para definir a qué base de datos hacer la petición:</p>

<pre><code class="python routers.py">class HistoricRouter(object):
    """
    A router to control all database operations on models in the historic application.
    """
    def db_for_read(self, model, **hints):
        """
        Attempts to read historic models go to historical.
        """
        if model._meta.app_label == 'historic':
            return 'historical'
        return None

    def db_for_write(self, model, **hints):
        """
        Attempts to write historic models go to historical.
        """
        if model._meta.app_label == 'historic':
            return 'historical'
        return None

    def allow_relation(self, obj1, obj2, **hints):
        """
        Allow relations if a model in the historic app is involved.
        """
        if obj1._meta.app_label == 'historic' or \
            obj2._meta.app_label == 'historic':
            return True
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        """
        Make sure the historic app only appears in the 'historical' database.
        """
        if app_label == 'historic':
            return db == 'historical'
        return None
</code></pre>

<p>En nuestros modelos especificamos <code>app_label</code> para referirnos a la base de datos distinta a <code>default</code>:</p>

<pre><code class="python models.py">class Author(models.Model):

    class Meta:
        db_table = 'authors'

class AbstractBook(models.Model):
    author = models.ForeignKey('books.Author', related_name='books')
    created_at = models.DateTimeField()

    class Meta:
        unmanaged = True
        abstract = True

class Book(Book):

    class Meta:
        db_table = 'books'

class HistoricBook(Book):

    class Meta:
        unmanaged = True
        db_table = 'books'
        app_label = 'historic'
</code></pre>

<p>La petición <code>Book.objects.all()</code> va a traer libros de la base de datos <code>production</code> y <code>HistoricBook.objects.all()</code> - de la base de datos <code>history</code>.</p>

<p>Modificando <code>allow_relation</code> en nuestro router, podemos permitir llaves foráneas entre modelos de diferentes bases de datos:</p>

<pre><code class="python">    def allow_relation(self, obj1, obj2, **hints):
        return True
</code></pre>

<p>Enlaces:</p>

<ul>
<li><a href="https://docs.djangoproject.com/en/1.10/topics/db/multi-db/#cross-database-relations">Django: Cross-database relations</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Flask for Django developers]]></title>
    <link href="http://blog.vero4ka.info/blog/2016/07/22/flask-for-django-developers/"/>
    <updated>2016-07-22T07:35:02-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2016/07/22/flask-for-django-developers</id>
    <content type="html"><![CDATA[<ol>
<li>Aplicación básica</li>
<li>Blueprints</li>
<li>URLs</li>
<li>Vistas</li>
<li>Plantillas (Jinja2)</li>
<li>Procesadores de contexto</li>
<li>Modelos (SQLAlchemy, CRUD)</li>
<li>Formularios</li>
<li>Autenticación</li>
<li>Múltiples idiomas</li>
<li>Mensajes (flash)</li>
<li>Cache</li>
</ol>


<iframe src="//slides.com/vero4ka/flask-para-desarrolladorres-de-django/embed?style=light" width="576" height="420" scrolling="no" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>


<ul>
<li>Slides: <a href="http://slides.com/vero4ka/flask-para-desarrolladorres-de-django/">http://slides.com/vero4ka/flask-para-desarrolladorres-de-django/</a></li>
<li>Examples: <a href="https://github.com/vero4karu/flask-examples">https://github.com/vero4karu/flask-examples</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Pruebas para formularios en Django]]></title>
    <link href="http://blog.vero4ka.info/blog/2015/09/30/pruebas-para-formularios-en-django/"/>
    <updated>2015-09-30T04:49:19-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2015/09/30/pruebas-para-formularios-en-django</id>
    <content type="html"><![CDATA[<p>En esta entrada de blog quiero compartir la forma en la que escribo ruebas para formularios en un proyecto de Django.</p>

<p>Primero vamos a instalar los paquetes necesarios:</p>

<p>{% codeblock %}
$ pip install django-webtest
$ pip install factory-boy
{% endcodeblock %}</p>

<p><a href="http://webtest.pythonpaste.org/en/latest/WebTest">WebTest</a> es una biblioteca que nos ayuda a escribir pruebas para las aplicaciones wsgi. Es mucho más poderosa comparando con <code>django.test.Client</code> que viene con Django.</p>

<p>En el archivo de configuración especificamos que vamos a usar la base de datos SQLite para correr nuestras pruebas:</p>

<p>{% codeblock test_settings.py lang:python %}
DATABASES = {
    &lsquo;default&rsquo;: {
        &lsquo;ENGINE&rsquo;: &lsquo;django.db.backends.sqlite3&rsquo;,
    }
}
{% endcodeblock %}</p>

<p>Suponemos que queremos escribir una prueba unitaria para una vista que crea un objeto del modelo <code>Event</code>:</p>

<p>{% codeblock models.py lang:python %}
class Event(models.Model):
    title = models.CharField(max_length=500)
    start_date = models.DateTimeField()
    end_date = models.DateTimeField(blank=True, null=True)
    people = models.ManyToManyField(&lsquo;history.Person&rsquo;, blank=True, related_name=&lsquo;events&rsquo;)</p>

<p>class Person(models.Model):
    name = models.CharField(max_length=255)
{% endcodeblock %}</p>

<p>Aquí está la vista que maneja el formulario para crear un evento:</p>

<p>{% codeblock views.py lang:python %}</p>

<p>class EventCreateView(LoginRequiredMixin, CreateView):
    model = Event
    form_class = EventForm
    success_url = reverse_lazy(&lsquo;history:timeline&rsquo;)
{% endcodeblock %}</p>

<p>Ahora escribimos nuestra prueba. Vamos a extender la clase <code>django_webtest.WebTest</code>, que en su lugar extiende <code>django.test.TestCase</code> de Django, y crear a un usuario:</p>

<p>{% codeblock tests.py lang:python %}
from django_webtest import WebTest</p>

<p>class HistoryViewsTests(WebTest):
    def setUp(self):
        self.superuser = get_user_model().objects.create_superuser(
            email=&lsquo;<a href="&#109;&#x61;&#x69;&#x6c;&#116;&#111;&#58;&#x73;&#117;&#112;&#101;&#x72;&#117;&#115;&#x65;&#x72;&#x40;&#x65;&#120;&#97;&#109;&#x70;&#x6c;&#101;&#46;&#x63;&#x6f;&#109;">&#x73;&#x75;&#112;&#101;&#x72;&#x75;&#x73;&#x65;&#x72;&#x40;&#101;&#x78;&#97;&#109;&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#109;</a>&rsquo;,
            username=&lsquo;superuser&rsquo;,
            password=&lsquo;secret&rsquo;,
        )
        super(HistoryViewsTests, self).setUp()</p>

<pre><code>def test_create_event(self):
    # código para nuestra prueba
</code></pre>

<p>{% endcodeblock %}</p>

<p>Ahora podemos probar que cuando un usuario trata de acceder nuestra página, se redirige al formulario de acceso (el códigos de estado HTTP es 302):</p>

<p>{% codeblock lang:python %}
url = reverse(&lsquo;history:event_create&rsquo;)
self.app.get(url, status=302)
{% endcodeblock %}</p>

<p>Ahora vamos a acceder la vista como superusuario:</p>

<p>{% codeblock lang:python %}
response = self.app.get(url, user=self.superuser, status=200)
{% endcodeblock %}</p>

<p>Como tenemos solo un formulario en la página, podemos obtenerlo por una de tres formas: por el atributo <code>.form</code>: <code>response.form</code>, por índice <code>response.forms[0]</code> o por <code>id</code> del formulario (artibuto HTML)<code>response.forms['event_form']</code>.</p>

<p>Para facilitar la depuración de nuestras pruebas, podemos pedir a mostrar el <code>response</code> en navegador predeterminado:</p>

<p>{% codeblock lang:python %}
response.showbrowser()
{% endcodeblock %}</p>

<p>Ahora podemos diligenciar nuestro formulario con los datos de prueba:</p>

<p>{% codeblock tests.py lang:python %}
class HistoryViewsTests(WebTest):
    # &hellip;</p>

<pre><code>def test_create_event(self):
    person1, person2, person3 = PersonFactory.create_batch(3)
    response = self.app.get(url, user=self.superuser, status=200)

    self.assertFalse(Event.objects.exists())

    form = response.forms['event_form']
    form['title'] = u'Título del evento'
    form['start_date'] = datetime.datetime.now()
    form['people'] = [person1.id, person2.id]
    form.submit().follow()

    self.assertEqual(Event.objects.count(), 1)

    event = Event.objects.first()
    self.assertEqual(event.title, u'Título del evento')

    people = event.people.all()
    self.assertIn(person1, people)
    self.assertIn(person2, people)
    self.assertNotIn(person3, people)
</code></pre>

<p>{% endcodeblock %}</p>

<p>Para generar objetos del modelo <code>Person</code> usamos la biblioteca <a href="http://factoryboy.readthedocs.org/">Factory Boy</a>:</p>

<p>{% codeblock factories.py lang:python %}
from ..models import Person</p>

<p>import factory
import factory.fuzzy</p>

<p>class PersonFactory(factory.django.DjangoModelFactory):
    name = factory.fuzzy.FuzzyText(length=50)</p>

<pre><code>class Meta:
    model = Person
</code></pre>

<p>{% endcodeblock %}</p>

<p>Así podemos acceder los opciones de una selección o selección múltiple:</p>

<p>{% codeblock lang:pycon %}</p>

<blockquote><blockquote><blockquote><p>print form[&lsquo;people&rsquo;].options
[(u'1', False, u'GLUZLvZfyjdZEmjNtnAJvsIVljodQjZpzLRDKrqJtYGiDLmSrN'), (u'2', False, u'vOxDBbmLaUXxJkJzcqYgLQpBieSoLtXJcpHCEPUpYUIzybhsAh'), (u'3', False, u'tfXSXCTIQICDwVPYvxZGSXgclFTnHbeYSQaMntxJNcgUJjzAwX')]
form[&lsquo;people&rsquo;] = [person1.id, person2.id]
print form[&lsquo;people&rsquo;].value
[u'1', u'2']
{% endcodeblock %}</p></blockquote></blockquote></blockquote>

<p>Ahora corremos nuestras pruebas y voilà:</p>

<p>{% codeblock %}
$ ./manage.py test
Creating test database for alias &lsquo;default&rsquo;&hellip;</p>

<h2>..</h2>

<p>Ran 1 test in 0.463s</p>

<p>OK
Destroying test database for alias &lsquo;default&rsquo;&hellip;
{% endcodeblock %}</p>

<p>Enlaces:</p>

<ul>
<li><a href="https://github.com/django-webtest/django-webtest">WebTest</a></li>
<li><a href="http://webtest.pythonpaste.org/en/latest/forms.html">Manejo de formularios con WebTest</a></li>
<li><a href="http://factoryboy.readthedocs.org/">Factory Boy</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
