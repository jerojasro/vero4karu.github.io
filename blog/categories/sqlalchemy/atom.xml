<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sqlalchemy | Cansada de ser feliz]]></title>
  <link href="http://blog.vero4ka.info/blog/categories/sqlalchemy/atom.xml" rel="self"/>
  <link href="http://blog.vero4ka.info/"/>
  <updated>2017-01-10T21:16:32-05:00</updated>
  <id>http://blog.vero4ka.info/</id>
  <author>
    <name><![CDATA[vero4ka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Monitoreo de acciones de usuarios en Flask (SQLAlchemy)]]></title>
    <link href="http://blog.vero4ka.info/blog/2016/07/22/monitoreo-de-acciones-de-usuarios-en-flask-sqlalchemy/"/>
    <updated>2016-07-22T08:23:58-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2016/07/22/monitoreo-de-acciones-de-usuarios-en-flask-sqlalchemy</id>
    <content type="html"><![CDATA[<p>Suponemos que en nuestro proyecto de Flask hay un modelo <code>Client</code> definidao usando <a href="http://flask-sqlalchemy.pocoo.org/">Flask-SQLAlchemy</a> y queremos monetorear los cambios que se realizan sobre los objetos de ese modelo.</p>

<p>Para esto agregamos tres señales:</p>

<pre><code class="python models.py">from sqlalchemy import event

from main.signals import receive_before_update, receive_before_insert, receive_before_delete

class Client(db.Model):
    id = Column(Integer, primary_key=True)
    name = Column(String(255))
    email = Column(String(255), unique=True)
    phone = Column(String(255))

event.listen(Client, 'before_insert', receive_before_insert)
event.listen(Client, 'before_update', receive_before_update)
event.listen(Client, 'before_delete', receive_before_delete)
</code></pre>

<p>EN el gódigo de cada señal llamamos los métodos <code>inspect()</code> y <code>get_history()</code> para detectar los cambios sobre el objeto:</p>

<pre><code class="python">state = db.inspect(client_object)
for attr in state.attrs:
     hist = state.get_history(attr.key, True)
</code></pre>

<p>Por ejemplo, para el atributo <code>name</code>:</p>

<pre><code class="json">{
    'added': ['Company A'],
    'deleted': ['Company B'],
}
</code></pre>

<p>El mégoto <code>get_history()</code> nos devuelve un objeto <code>sqlalchemy.orm.attributes.History</code> que tiene los siguientes atributos:</p>

<ul>
<li><code>added</code> - listado de valores agregados al atributo de nuestro objeto</li>
<li><code>deleted</code> - listado de valores eliminados del atributo de nuestro objeto</li>
<li><code>unchanged</code> - listado de valores del atributo de nuestro objeto que se quedaron intactos</li>
<li><code>has_changes()</code> - método que retorna <code>True</code> si no habían ningunos cambios de valor de nuestro atributo.</li>
</ul>


<p>Ahora, usando la variable <code>current_user</code> de la biblioteca <a href="https://flask-login.readthedocs.io/">Flask-Login</a>, podemos guargar el usuario que realizó los cambios:</p>

<pre><code class="python signals.py">from flask_login import current_user

def save_changes(target, action):
    try:
        state = db.inspect(target)
        changes = {}
        for attr in state.attrs:
            hist = state.get_history(attr.key, True)
            if not hist.has_changes():
                continue
            added = format_changes_value(hist.added)
            deleted = format_changes_value(hist.deleted)
            if added != deleted:
                changes[attr.key] = {
                    'added': added,
                    'deleted': deleted,
                }
        if changes:
            mongo.db.user_logs.insert_one(dict(
                current_user_id=current_user.id,
                action=action,
                table_name=target.__tablename__,
                object_id=target.id,
                changes=changes,
                created_at=datetime.datetime.utcnow(),
            ))
    except Exception as e:
        pass

def receive_before_insert(mapper, connection, target):
    save_changes(target, 'create')


def receive_before_update(mapper, connection, target):
    save_changes(target, 'update')


def receive_before_delete(mapper, connection, target):
    save_changes(target, 'delete')
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL to SQLAlchemy conversions]]></title>
    <link href="http://blog.vero4ka.info/blog/2016/05/04/sql-to-sqlalchemy-conversions/"/>
    <updated>2016-05-04T21:15:39-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2016/05/04/sql-to-sqlalchemy-conversions</id>
    <content type="html"><![CDATA[<p>Some examples on how to convert raw SQL to SQLAlchemy query:</p>

<h3>Select all</h3>

<pre><code class="sql">SELECT COUNT(*)
</code></pre>

<pre><code class="python">&gt; from sqlalchemy import text, func
&gt; db.session.query(func.count()).all()
</code></pre>

<h3>Add labels</h3>

<pre><code class="sql">SELECT COUNT(*) as requiests
</code></pre>

<pre><code class="python">&gt; rows = db.session.query(func.count().label('requests')).all()
&gt; row = rows[0]
&gt; row.requests
12
</code></pre>

<h3>Sum</h3>

<pre><code class="sql">SELECT SUM(status) as rides
</code></pre>

<pre><code class="python">&gt; rows = db.session.query(func.sum(Book.status).label('books')).all()
&gt; row = rows[0]
&gt; row.books
12
</code></pre>

<h3>Return a count of rows and distinct</h3>

<pre><code class="sql">SELECT COUNT(DISTINCT(author_id)) as authors
</code></pre>

<pre><code class="python">from sqlalchemy import distinct
&gt; rows = db.session.query(
    func.count(distinct(Book.author_id)).label('authors')
).all()
</code></pre>

<h3>Query a date range</h3>

<pre><code class="sql">SELECT * FROM b WHERE b.created_at &gt; current_timestamp - (current_timestamp - interval '5 hours')::time
</code></pre>

<pre><code class="python">&gt; now = datetime.datetime.utcnow()
&gt; db.session.query(Book).filter(
    Book.created_at.between(now - datetime.timedelta(hours=5), now)
).all()
</code></pre>

<h3>Conditional sum</h3>

<pre><code class="sql">SELECT SUM(((status IN (4, 7))::int)) as books ...
</code></pre>

<pre><code class="python">&gt; from sqlalchemy.sql.expression import case
&gt; db.session.query(
    func.sum(case([(Book.status.in_((4, 7)), 1)], else_=0)).label('books'),
).filter(
    # ...
).all()
</code></pre>

<h3>In</h3>

<pre><code class="python">&gt; Book.query.filter(
    Book.status.in_((
        BOOK_CONFIRMED,
        BOOK_FINISHED,
    )),
).count()
</code></pre>

<h3>Other examples</h3>

<pre><code class="python">today = datetime.datetime.utcnow().date()
six_months_ago = today - relativedelta(months=6)

books = db.session.query(
    func.to_char(Book.created_at, 'MM'),
    func.count(Book.created_at)
).filter(
    Book.author_id == author.id,  # Filter books by author
).filter(
    Book.created_at.between(six_months_ago_min, today_max)  # Get all books created in last six months
).group_by(
    func.to_char(Book.created_at, 'MM')
).order_by(func.to_char(Book.created_at, 'MM')).all()
</code></pre>
]]></content>
  </entry>
  
</feed>
