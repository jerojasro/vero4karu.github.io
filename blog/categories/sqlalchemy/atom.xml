<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: sqlalchemy | Cansada de ser feliz]]></title>
  <link href="http://blog.vero4ka.info/blog/categories/sqlalchemy/atom.xml" rel="self"/>
  <link href="http://blog.vero4ka.info/"/>
  <updated>2017-03-20T17:35:43-05:00</updated>
  <id>http://blog.vero4ka.info/</id>
  <author>
    <name><![CDATA[vero4ka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Flask con todas las arandelas]]></title>
    <link href="http://blog.vero4ka.info/blog/2017/01/20/flask-con-todas-las-arandelas/"/>
    <updated>2017-01-20T09:18:28-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2017/01/20/flask-con-todas-las-arandelas</id>
    <content type="html"><![CDATA[<iframe src="//slides.com/vero4ka/flask-con-todas-las-arandelas/embed?style=light" width="576" height="420" scrolling="no" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>




<!-- more -->


<h2>Para empezar</h2>

<p>Hay muchos recursos acerca de Flask en los internetes, pero aquí me gustaría mencionar los tres que considero fundamentales.</p>

<p>El primero, por supuesto, es la documentación oficial del framework: <a href="http://flask.pocoo.org/docs/">flask.pocoo.org/docs</a>.</p>

<p>Luego, es muy bueno mirar el libro de Miguel Grinberg: <a href="https://flaskbook.com/">flaskbook.com</a>, en donde se explica de forma bastante detallada cómo hacer una plataforma de publicación de entradas de blog. El código, que sirve como ejemplo en el libro, se puede encontrar en la página de github del autor. Como material complementario al libro, es muy recomendado echar una mirada en el <a href="https://blog.miguelgrinberg.com/">blog personal de Miguel Grinberg</a>, donde el autor cubre los temas más específicos del desarrollo en Flask.</p>

<p>Y ahora, como dijo el astronauta ruso Yuri Gagarin en el momento del despegue de su nave Vostok 1: &ldquo;¡Poyejali!&rdquo;&ldquo; (en ruso: Поехали!; se traduce como «¡Vámonos!»).</p>

<h2>Aplicación básica</h2>

<p>Empezamos con instalar <strong>Flask</strong>:</p>

<pre><code>$ mkvirtualenv pycon2017 -p python3
$ pip install Flask
</code></pre>

<p>Al momento de ésta presentación la última versión del framework es <strong>0.12</strong>.</p>

<p>Ahora creamos nuestra primera aplicación de Flask que va a ser sólo un archivo de Python:</p>

<p>{% codeblock app.py lang:python %}
from flask import Flask
app = Flask(<strong>name</strong>)</p>

<p>@app.route(&ldquo;/&rdquo;)
def hello():
    return &ldquo;Hello World!&rdquo;</p>

<p>if <strong>name</strong> == &ldquo;<strong>main</strong>&rdquo;:
    app.run()
{% endcodeblock %}</p>

<p>El decorador <code>route</code> nos ayuda a definir la ruta de URL para la vista llamada <code>hello</code> que simplemente devuelve al navegador la respuesta HTTP 200 con la frase &ldquo;Hello World!&rdquo;.</p>

<p>Corremos la aplicación con el siguiente comando:</p>

<pre><code>$ python app.py 
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
</code></pre>

<p>Y ahora lo podemos abrir en nuestro navegador:</p>

<p>{% img center /images/flask/flask_01.png %}</p>

<h2>manage.py</h2>

<p>Nosotros, por experiencia con otros frameworks, ya nos acostumbramos a la posibilidad de acceder al shell de Python de nuestra aplicación, o con poder correr comandos, que pertenecen a la aplicación, desde la consola. Para tener todo esto en Flask, instalamos un librería llamada <code>Flask-Script</code>.</p>

<pre><code>$ pip install Flask-Script
</code></pre>

<p>Ahora separamos nuestra aplicación en dos archivos: en el primero vamos iniciar la app de Flask, en la que especificamos la ruta de los archivos estáticos y del archivo de configuración (equivalente de <code>settings.py</code> en Django)</p>

<p>{% codeblock run.py lang:python %}
from flask import Flask</p>

<p>def create_app():
    app = Flask(<strong>name</strong>,
        static_url_path=&lsquo;/static&rsquo;)
    app.config.from_object(&lsquo;conf.config&rsquo;)
    return app
{% endcodeblock %}</p>

<p>y en el segundo vamos a colocar una instancia de <strong>Manager</strong>, que se encaragará de correr la aplicación con <code>python manage.py</code>:</p>

<p>{% codeblock manage.py lang:python %}
from flask.ext.script import Manager
from run import create_app</p>

<p>app = create_app()
manager = Manager(app)</p>

<p>@app.route(&ldquo;/&rdquo;)
def hello():
    return &ldquo;Hello World!&rdquo;</p>

<p>if <strong>name</strong> == &lsquo;<strong>main</strong>&rsquo;:
    manager.run()
{% endcodeblock %}</p>

<p>Corriendo el siguiente comando en la consola</p>

<pre><code>$ ./manage.py runserver -h HOST -p PORT
</code></pre>

<p>podemos ver la misma aplicación, como en el paso anterior, pero ahora podemos además acceder a shell usando el comando</p>

<pre><code>$ ./manage.py shell
In [1]:
</code></pre>

<h2>Configuración</h2>

<p>Miremos con más atención la estructura del proyecto:</p>

<pre><code>├── conf
│   ├── config.py
│   ├── __init__.py
│   └── local_config.py
├── manage.py
└── run.py
</code></pre>

<p>Ahora tenemos una carpeta con los archivos de configuración - <code>conf</code>:</p>

<p>{% codeblock conf/config.py lang:python %}
import sys</p>

<p>DEBUG = False</p>

<p>try:
    if &lsquo;test&rsquo; in sys.argv:
        from test_config import *
    else:
        from local_config import *
except ImportError:
    pass
{% endcodeblock %}</p>

<p>Más información acerca de la configuración en Flask se puede encontrar en la página <a href="http://flask.pocoo.org/docs/0.12/config/">flask.pocoo.org/docs/0.12/config/</a>.</p>

<h2>Blueprints</h2>

<p>Cuando nuestro archivo con las vistas crezca, vamos a querer a separar la lógica de nuestra aplicación en módulos diferentes (así como lo tenemos con apps de Django):</p>

<pre><code>├── conf
│   ├── config.py
│   ├── __init__.py
│   └── local_config.py
├── app1
│   ├── templates
│   └── views.py
├── app2
│   ├── templates
│   └── views.py
├── manage.py
└── run.py
</code></pre>

<p>En este caso nos ayuda un concepto de crear aplicaciones llamado <strong>Blueprints</strong>. La información completa acerca de Blueprints se puede encontrar en la documentación de Flask: <a href="http://flask.pocoo.org/docs/0.12/blueprints/">flask.pocoo.org/docs/0.12/blueprints/</a>.</p>

<p>Creamos un Blueprint para nuestra aplicación, donde vamos a guardar las vistas relacionadas a nuestros usuarios, por ejemplo:</p>

<p>{% codeblock users/views.py lang:python %}
from flask import Blueprint</p>

<p>users = Blueprint(
    &lsquo;users&rsquo;,
    <strong>name</strong>,
    template_folder=&lsquo;templates&rsquo;)</p>

<p>@users.route(&lsquo;/&rsquo;)
def hello():
    return &lsquo;Hello Worlds!&rsquo;
{% endcodeblock %}</p>

<p>y lo registramos en el archivo <code>run.py</code>:</p>

<p>{% codeblock run.py lang:python %}
from flask import Flask</p>

<p>def create_app():
    app = Flask(<strong>name</strong>,
        static_url_path=&lsquo;/static&rsquo;)
    app.config.from_object(&lsquo;conf.config&rsquo;)</p>

<pre><code>from users.views import users
app.register_blueprint(users, url_prefix='/users')

return app
</code></pre>

<p>{% endcodeblock %}</p>

<p>indicando en el argumento <code>url_prefix</code> del método <code>register_blueprint</code>, que todos los URLs, relacionados con el Blueprint de usuario, van a empezar con el prefijo <code>/users</code>, por ejemplo: <a href="http://localhost:5000/users/">http://localhost:5000/users/</a>.</p>

<h2>URLs</h2>

<p>Miremos cómo se definen los URLs en Flask.</p>

<p>Primero, hay formas diferentes de especificar la ruta: usando el decorador de Blueprint <code>@users.route</code> o el método <code>users.add_url_rule</code>:</p>

<pre><code class="python">@users.route('/user/&lt;name&gt;')
def user_profile(name):
    return '&lt;h1&gt;Hello, {}!&lt;/h1&gt;'.format(name)

def users_list():
    pass
users.add_url_rule('/', 'users_list', users_list)
</code></pre>

<p>En el primer ejemplo podemos ver, que a la vista se pasa el parámetro de URL <code>name</code>, al que luego accedemos desde el parámetro <code>name</code> de la vista <code>user_profile</code>.</p>

<p>Flaks permite especificar el tipo de parámetro que esperamos. Por ejemplo, para los números enteros, el decorador de escribe así:</p>

<pre><code class="python">@users.route('/user/&lt;int:pk&gt;')
def user_detail(pk):
    return '&lt;h1&gt;Hello, user #{}!&lt;/h1&gt;'.format(pk)
</code></pre>

<p>También se puede explícitamente indicar el método HTTP, que acepta la vista.</p>

<pre><code class="python">@users.route('/user/&lt;int:pk&gt;/create', methods=('POST',))
def user_create(pk):
    pass
</code></pre>

<p>En este caso al tratar de acceder a la vista con el método GET, obtenemos el error 405 (Method not allowed).</p>

<p>Para obtener el URL, que corresponde a la vista usamos el método <code>url_for</code>, al que pasamos el nombre del Blueprint y el nombre de la vista:</p>

<pre><code class="python">from flask import url_for

url_for('users.user_detail', pk=user_pk)
</code></pre>

<h2>Vistas</h2>

<h4>Request</h4>

<p>En Flask el objeto <code>request</code> no se está pasando como parámetro al la vista (como en Django, por ejemplo), sino que es una variable global:</p>

<pre><code>GET http://localhost:5000/users/user/1?q=foo
</code></pre>

<p>{% codeblock users/views.py lang:python %}
from flask import Blueprint, request</p>

<p>users = Blueprint(&lsquo;users&rsquo;, <strong>name</strong>, template_folder=&lsquo;templates&rsquo;)</p>

<p>@users.route(&lsquo;/user/&lt;int:pk>&rsquo;)
def user_detail(pk):
    print(request)
    print(request.method)  # GET
    print(request.args)    # ImmutableMultiDict([(&lsquo;q&rsquo;, u'foo')])
    print(request.headers)
    return &lsquo;<h1>Hello, user #{}!</h1>&rsquo;.format(pk)
{% endcodeblock %}</p>

<h4>Decoradores</h4>

<p>Aparte de la definición de ruta, la vista en Flask puede tener otros decoradores, por ejemplo:</p>

<p>{% codeblock users/views.py lang:python %}
@users.route(&lsquo;/user/&lt;int:pk>&rsquo;)
@login_required
def user_detail(pk):
    return &lsquo;<h1>Hello, user #{}!</h1>&rsquo;.format(pk)
{% endcodeblock %}</p>

<h2>Plantillas</h2>

<p>Ahora vamos a renderizar una plantilla desde nuestra vista. Para eso vamos a usar el método <code>render_template</code> que recibe como argumentos la ruta hasta la plantilla dentro de la carpeta que especificamos en el parámetro <code>template_folder</code> del Blueprint, y los demás argumentos que son los parámetros de contexto.</p>

<p>{% codeblock users/views.py lang:python %}
from flask import Blueprint
from flask import render_template</p>

<p>users = Blueprint(&lsquo;users&rsquo;, <strong>name</strong>, template_folder=&lsquo;templates&rsquo;)</p>

<p>@users.route(&lsquo;/user/&lt;int:pk>&rsquo;)
def user_detail(pk):
    return render_template(&lsquo;users/detail.html&rsquo;, user_id=pk)
{% endcodeblock %}</p>

<p>{% codeblock users/templates/users/detail.html lang:html %}
{% raw %}
<html>
  <body>
    <h1>Hello, user #{{ user_id }}!</h1>
  </body>
</html>
{% endraw %}
{% endcodeblock %}</p>

<h3>Jinja2</h3>

<p>Para renderizar plantillas Flask usa el lenguaje <code>Jinja2</code>. Vamos a mirar algunas de sus funcionalidades:</p>

<h4>Variables:</h4>

<p>{% codeblock lang:html %}
{% raw %}
{{ foo.bar }}
{{ foo[&lsquo;bar&rsquo;] }}
{% endraw %}
{% endcodeblock %}</p>

<h4>Condicionales:</h4>

<p>{% codeblock lang:html %}
{% raw %}
{% if user.address %}
    <p>{{ user.address }}</p>
{% endif %}
{% endraw %}
{% endcodeblock %}</p>

<h5>Bucles:</h5>

<p>{% codeblock lang:html %}
{% raw %}
{% for user in users %}
  <li>{{ user.name }}</li>
{% else %}
  <li>No hay usuarios</li>
{% endfor %}
{% endraw %}
{% endcodeblock %}</p>

<h5>Bloques:</h5>

<p>{% codeblock lang:html %}
{% raw %}
{% block title %}Usuarios{% endblock %}
{% endraw %}
{% endcodeblock %}</p>

<h5>Extender una plantilla base:</h5>

<p>{% codeblock lang:html %}
{% raw %}
{% extends &ldquo;layouts/main.html&rdquo; %}
{% endraw %}
{% endcodeblock %}</p>

<h4>Comentario:</h4>

<p>{% codeblock lang:html %}
{% raw %}
{# Texto #}
{% endraw %}
{% endcodeblock %}</p>

<h5>Incluir otra plantilla:</h5>

<p>{% codeblock lang:html %}
{% raw %}
{% with rating=user.rating %}
    {% include &lsquo;includes/_rating.html&rsquo; %}
{% endwith %}
{% endraw %}
{% endcodeblock %}</p>

<h5>Asignar un valor a una variable local:</h5>

<p>{% codeblock lang:html %}
{% raw %}
{% set permissions = user.get_permission() %}
{{ permissions }}
{% endraw %}
{% endcodeblock %}</p>

<h5>Filtros:</h5>

<p>{% codeblock lang:html %}
{% raw %}
{{ user.address|default(&lsquo;N/A&rsquo;) }}
{% endraw %}
{% endcodeblock %}</p>

<h2>Procesadores de contexto</h2>

<p>De forma predeterminada, el contexto de todas las plantillas ya tiene las siguientes variables:</p>

<ul>
<li><code>config</code> - Objeto de configuración (<code>flask.config</code>)</li>
</ul>


<p>{% codeblock lang:html %}{% raw %}
{{ config.DEBUG }}
{% endraw %}{% endcodeblock %}</p>

<ul>
<li><code>request</code> - Objeto de la petición actual (<code>flask.request</code>)</li>
</ul>


<p>{% codeblock lang:html %}{% raw %}
{{ request.path }}
{% endraw %}{% endcodeblock %}</p>

<ul>
<li><code>session</code> - Objeto de sesión (<code>flask.session</code>)</li>
<li><code>g</code> - Variables globales</li>
</ul>


<p>Hay una forma de tener <code>context_processors</code> (como en Django) para poder pasar variables a todas las plantillas del proyecto:</p>

<p>{% codeblock run.py lang:python %}
from flask import Flask</p>

<p>def create_app():
    app = Flask(<strong>name</strong>, static_url_path=&lsquo;/static&rsquo;)
    app.config.from_object(&lsquo;conf.config&rsquo;)</p>

<pre><code>from users.views import users
app.register_blueprint(users, url_prefix='/users')

@app.context_processor
def constants_processor():
    return {
        'say_hello': 'Hola',
    }

return app
</code></pre>

<p>{% endcodeblock %}</p>

<p>Ahora podemos acceder a la variable <code>say_hello</code> desde todas las plantillas sin tener que pasarla cada vez explícitamente:</p>

<p>{% codeblock users/templates/users/detail.html lang:html %}
{% raw %}
<html>
  <body>
    <h1>{{ say_hello }}, user #{{ user_id }}!</h1>
  </body>
</html>
{% endraw %}
{% endcodeblock %}</p>

<h2>Modelos</h2>

<h3>SQLAlchemy</h3>

<p>Hay dos librerías que nos permiten trabajar con modelos y hacer peticiones SQL desde Flask.</p>

<pre><code>$ pip install SQLAlchemy
$ pip install Flask-SQLAlchemy
</code></pre>

<p>Una es <code>SQLAlchemy</code> y la otra es su extensión para Flask - <code>Flask-SQLAlchemy</code>, que viene con algunas funcionalidades adicionales y útiles en el desarrollo web, por ejemplo, el método <code>first_or_404()</code> para obtener el primer elemento del query o error HTTP 404 si no existe, o el método <code>paginate()</code> para realizar paginación sobre los objetos de <code>BaseQuery</code>.</p>

<p>Ahora incluimos <code>SQLAlchemy</code> como una aplicación externa de nuestro proyecto. Primero creamos una variable <code>db</code> para que el import no se rompa cuando la aplicación todavía no se ha inicializado, y en <code>create_app</code> cuando inicializamos la aplicación: <code>db.init_app(app)</code>.</p>

<p>{% codeblock run.py lang:python %}
from flask_sqlalchemy import SQLAlchemy</p>

<p>db = SQLAlchemy()</p>

<p>def create_app():
    app = Flask(<strong>name</strong>, static_url_path=&lsquo;/static&rsquo;)
    app.config.from_object(&lsquo;conf.config&rsquo;)</p>

<pre><code>db.init_app(app)
return app
</code></pre>

<p>{% endcodeblock %}</p>

<p>En el archivo de configuración colocamos la ruta hacia nuestra base de datos.</p>

<p>{% codeblock conf/config.py lang:python %}
SQLALCHEMY_DATABASE_URI = &lsquo;sqlite:////tmp/test.db&rsquo;
{% endcodeblock %}</p>

<p>Y ahora podemos crear los modelos. Aquí en el ejemplo se puede ver cómo definir modelos, columnas de tipos diferentes y crear llaves foráneas</p>

<p>{% codeblock users/models.py lang:python %}
from run import db</p>

<p>class User(db.Model):
    <strong>tablename</strong> = &lsquo;users&rsquo;</p>

<pre><code>id = db.Column(db.Integer, primary_key=True)
username = db.Column(db.String(80), unique=True)
email = db.Column(db.String(120), unique=True)
city_id = db.Column(db.ForeignKey(u'cities.id'), nullable=False, index=True)
created_at = db.Column(db.DateTime, nullable=False, default=db.func.now())
updated_at = db.Column(db.DateTime, nullable=False, default=db.func.now(),
                    onupdate=db.func.now())

def __repr__(self):
    return '&lt;Usuario %r&gt;' % self.username
</code></pre>

<p>class City(db.Model):
    <strong>tablename</strong> = &lsquo;cities&rsquo;</p>

<pre><code>id = db.Column(db.Integer, primary_key=True)
name = db.Column(db.String(255))

users = db.relationship('User', backref='city', lazy='dynamic')
</code></pre>

<p>{% endcodeblock %}</p>

<h3>CRUD</h3>

<p>Miramos los métodos de CRUD básicos que nos ofrece el ORM de SQLAlchemy.</p>

<h5>Crear</h5>

<p>{% codeblock lang:python %}
user = User(email=&lsquo;<a href="&#x6d;&#x61;&#x69;&#108;&#116;&#x6f;&#x3a;&#106;&#111;&#104;&#x6e;&#64;&#101;&#120;&#x61;&#109;&#x70;&#x6c;&#x65;&#x2e;&#x63;&#111;&#109;">&#106;&#x6f;&#x68;&#x6e;&#x40;&#x65;&#x78;&#x61;&#109;&#112;&#108;&#101;&#x2e;&#x63;&#x6f;&#x6d;</a>&rsquo;, username=&lsquo;&rsquo;)
db.session.add(user)
db.session.commit()
{% endcodeblock %}</p>

<h5>Obtener todos los usuarios</h5>

<p>{% codeblock lang:python %}
users = User.query.all()  # [<Usuario john'>, <Usuario u'admin'>]
{% endcodeblock %}</p>

<h5>Obtener el primer usuario</h5>

<p>{% codeblock lang:python %}
john = User.query.first()  # <Usuario 'john'>
{% endcodeblock %}</p>

<h5>Filtrar usuarios y ordenar</h5>

<p>{% codeblock lang:python %}
User.query.filter_by(username=&lsquo;john&rsquo;).all()
User.query.filter(
    User.created_at >= (datetime.datetime.utcnow() - datetime.timedelta(days=3)
).order_by(User.created_at.desc()).limit(10).all()
{% endcodeblock %}</p>

<h5>Borrar</h5>

<p>{% codeblock lang:python %}
db.session.delete(user)
db.session.commit()
{% endcodeblock %}</p>

<p><code>BaseQuery</code> no tiene método <code>save()</code>, sino todos los cambios que hacemos a objetos de modelos se agregan a la sesión. Como la sesión sólo vive durante la petición, para que nuestos cambios sean enviados a la base de datos, hace falta llamar el método <code>db.session.commit()</code>.</p>

<h2>Formularios</h2>

<p>Existen varias librerías de Python que nos permiten trabajar con formularios. En este ejemplo vamos a mirar una llamada <code>Flask-WTF</code>.</p>

<pre><code>$ pip install Flask-WTF
$ pip install Flask-Bootstrap
</code></pre>

<p>Vamos a usarla junto con una librería complementaria - <code>Flask-Bootstrap</code> - que lo único que hace es generar el código de HTML del formulario con la estructura y las clases de <a href="http://getbootstrap.com/2.3.2/">Twitter Bootstrap</a> (lo mismo que hace <code>django-crispy-forms</code>).</p>

<p>{% codeblock users/forms.py lang:python %}
import wtforms
from flask_wtf import Form</p>

<p>class UserForm(Form):
    email = wtforms.StringField(
        validators=[
            wtforms.validators.Email(),
            wtforms.validators.DataRequired(),
        ],
    )
    username = wtforms.StringField(
        validators=[wtforms.validators.DataRequired()],
    )
    submit = wtforms.SubmitField(&lsquo;Save&rsquo;)
{% endcodeblock %}</p>

<p>Ahora podemos renderizar el formulario en nuestra plantilla:</p>

<p>{% codeblock users/templates/users/form.html lang:html %}{% raw %}
{% extends &ldquo;layouts/main_layout.html&rdquo; %}
{% import &ldquo;bootstrap/wtf.html&rdquo; as wtf %}</p>

<p>{% block content %}
  {{ wtf.quick_form(form) }}
{% endblock %}
{% endraw %}{% endcodeblock %}</p>

<p>Este código nos va a renderizar el formulario completo con todos los campos especificados. Si queremos renderizar sólo algunos campos específicos, podemos escribirlo de la siguiente forma:</p>

<p>{% codeblock users/templates/users/form.html lang:html %}{% raw %}
{{ wtf.form_field(form.email) }}
{{ wtf.form_field(form.submit) }}
{% endraw %}{% endcodeblock %}</p>

<p>Lo único que hace falta es escribir una vista que reciba los datos del formulario y los guarde en la base de datos, por ejemplo.</p>

<p>El diccionario con los valores para cada campo se encuentra en la variable <code>request.form</code>. Si el request tiene método POST, validamos el formulario <code>form.validate()</code>, y en el caso exitoso, pasamos los valores del formulario a nuestro objeto: <code>form.populate_obj(user)</code>.</p>

<p>{% codeblock users/views.py lang:python %}
@users.route(&lsquo;/update/&lt;int:pk>/&rsquo;, methods=(&lsquo;GET&rsquo;, &lsquo;POST&rsquo;))
def user_update(pk):
    user = User.query.filter_by(id=pk).first_or_404()</p>

<pre><code>form = UserForm(user, request.form)

if request.method == 'POST' and form.validate():
    form.populate_obj(user)

    db.session.add(user)
    db.session.commit()

    flash('Usuario fue editado exitosamente', 'success')
    return redirect(url_for('users.user_detail', pk=user.id))

return render_template(
    'users/form.html',
    form=form,
)
</code></pre>

<p>{% endcodeblock %}</p>

<h2>Autenticación</h2>

<p>Para agregar autenticación al proyecto de Flask, normalmente usan las dos siguientes librerías:</p>

<pre><code>$ pip install Flask-Login
$ pip install Flask-OAuth
</code></pre>

<p>La primera tiene toda la funcionalidad de ingreso, salida de usuario. La podemos instalar de la misma forma, que hicimos con SQLAlchemy hace poco:</p>

<p>{% codeblock run.py lang:python %}
from flask_login import LoginManager</p>

<p>login_manager = LoginManager()
login_manager.login_view = &lsquo;users.login&rsquo;</p>

<p>def create_app():
    app = Flask(<strong>name</strong>, static_url_path=&lsquo;/static&rsquo;)
    app.config.from_object(&lsquo;conf.config&rsquo;)
    app.permanent_session_lifetime = datetime.timedelta(days=365)</p>

<pre><code>login_manager.init_app(app)
</code></pre>

<p>{% endcodeblock %}</p>

<p>En <code>login_manager.login_view</code> especificamos qué vista corresponde al ingreso (login), y en <code>permanent_session_lifetime</code>  se puede indicar el tiempo en el qué durará activa la sesión.</p>

<p>El modelo que vamos a usar para usuarios debe heredar de <code>UserMixin</code> de <code>flask_logins</code></p>

<p>{% codeblock users/models.py lang:python %}
from flask_login import UserMixin
from run import db</p>

<p>class User(db.Model, UserMixin):
    <strong>tablename</strong> = &lsquo;users&rsquo;</p>

<pre><code>id = Column(Integer, primary_key=True)
# ...
</code></pre>

<p>{% endcodeblock %}</p>

<p>Y ahora usando la otra librería - <code>Flask-OAuth</code> - podemos hacer una vista para que nuestros usuarios puedan ingresar desde su cuenta de Google, por ejemplo:</p>

<p>{% codeblock users/views.py lang:python %}
@users.route(&lsquo;/login&rsquo;)
def login():
    callback = url_for(&lsquo;users.authorized&rsquo;, _external=True)
    return google.authorize(callback=callback)
{% endcodeblock %}</p>

<p>Cuando el usuario ya está autenticado, en cualquier punto de nuestra aplicación podemos preguntar por el objeto correspondiente:</p>

<pre><code class="python">from flask_login import current_user
</code></pre>

<p>En la siguiente dirección se puede encontrar más información acerca de cómo configurar los tokens de autenticación Google: <a href="https://pythonhosted.org/Flask-OAuth/">pythonhosted.org/Flask-OAuth/</a>.</p>

<h2>Múltiples idiomas</h2>

<p>Si queremos tener soporte de múltiples idiomas, tendremos que instalar otra librería:</p>

<pre><code>$ pip install Flask-Babel
</code></pre>

<p>Miremos qué comandos nos ofrece:</p>

<p>{% codeblock lang:bash %}</p>

<h1>Extraer los textos para traducción</h1>

<h1>(se corre sólo una vez al principio)</h1>

<p>$ pybabel extract -F babel.cfg -o messages.pot .</p>

<h1>Generar un catálogo para español</h1>

<p>$ pybabel init -i messages.pot -d translations -l es</p>

<h1>Se crea el directorio translations/es</h1>

<h1>Por dentro hay otro directorio llamado LC_MESSAGES que tiene</h1>

<h1>un archivo messages.po.</h1>

<h1>Después de traducir los textos y guardarlos en messages.po,</h1>

<h1>compilamos el archivo y publicamos los textos:</h1>

<p>$ pybabel compile -d translations</p>

<h1>Para actualizar las traducciones a diario:</h1>

<p>$ pybabel extract -F babel.cfg -o messages.pot .
$ pybabel update -i messages.pot -d translations
{% endcodeblock %}</p>

<p>Si queremos traducir cadenas de texto dentro del código de Python, habrá que usar la siguiente sintaxis:</p>

<p>{% codeblock lang:python %}
from flask_babel import gettext as _</p>

<p>_(&lsquo;Invalid authentication token&rsquo;)
{% endcodeblock %}</p>

<p>Y en plantillas se ve muy parecido:</p>

<p>{% codeblock lang:html %}{% raw %}
<button class="btn btn-default" title="{{ _('Help') }}">
    <i class="fa fa-question"></i>
</button>
{% endraw %}{% endcodeblock %}</p>

<h2>Mensajes</h2>

<p>Los que están familiarizados con el framework Django, seguramente recuerdan que Django tiene un procesador de contexto <code>messages</code> que nos permite mandar mensajes a las plantillas desde el código Python:</p>

<p>{% codeblock lang:python %}
from django.contrib import messages</p>

<p>messages.add_message(request, messages.INFO, &lsquo;Hello world.&rsquo;)
{% endcodeblock %}</p>

<p>En Flask es muy parecido, sólo que esos mensajes se llaman <code>flash</code>:</p>

<p>{% codeblock lang:python %}
from flask import flash</p>

<p>flash(&lsquo;Hello world.&rsquo;, &lsquo;success&rsquo;)
{% endcodeblock %}</p>

<p>y para consultarlos dentro de la plantilla llamamos el método <code>get_flashed_messages</code>:</p>

<p>{% codeblock lang:html %}{% raw %}
{% for category, message in get_flashed_messages(with_categories=true) %}</p>

<div class="alert alert-{{ category|replace('message', 'info') }}">
  <button type="button" class="close" data-dismiss="alert">×</button>
  {{ message }}
</div>


<p>{% endfor %}
{% endraw %}{% endcodeblock %}</p>

<h2>Caché</h2>

<p>Y para terminar la presentación, vamos a meter todo en caché #comonosgusta:</p>

<pre><code>$ pip install Flask-Cache
</code></pre>

<p>Ya conocemos cómo instalar las aplicaciones externas en Flask, pero repasémoslo:</p>

<p>{% codeblock run.py lang:python %}
from flask_cache import Cache</p>

<p>cache = Cache()</p>

<p>def create_app():
    app = Flask(<strong>name</strong>, static_url_path=&lsquo;/static&rsquo;)
    app.config.from_object(&lsquo;conf.config&rsquo;)</p>

<pre><code>cache.init_app(app)
</code></pre>

<p>{% endcodeblock %}</p>

<p>Y ahora sí, vamos con toda&hellip; ponemos en caché una vista completa:</p>

<p>{% codeblock users/views.py lang:python %}
from run import cache</p>

<p>@users.route(&lsquo;/list&rsquo;)
@cache.cached(timeout=60*60, key_prefix=&lsquo;user_list&rsquo;)
def user_list():
    pass
{% endcodeblock %}</p>

<p>y luego un fragmento de html:</p>

<p>{% codeblock lang:html %}{% raw %}
{% cache 60*60, &lsquo;dashboard_menu_user&rsquo; + current_user.id|string %}
  {% include &lsquo;layouts/_menu.html&rsquo; %}
{% endcache %}
{% endraw %}{% endcodeblock %}</p>

<h2>pip freeze</h2>

<p>Y ahora vamos resumir qué librerías hemos instalado y cuales otras nos podrían ser útiles en el futuro:</p>

<p>{% codeblock %}{% raw %}</p>

<h1>Framework</h1>

<p>Flask==0.11</p>

<h1>Libs</h1>

<p>celery==3.1.20
coverage==4.0.3
factory-boy==2.6.1
SQLAlchemy==1.0.12
SQLAlchemy-Utils==0.31.6</p>

<h1>Flask libs</h1>

<p>Flask-And-Redis==0.6
Flask-Babel==0.9               # Múltiples idiomas y zonas horarias
Flask-Bootstrap==3.3.5.7       # ~ django-crispy-forms para Bootstrap
Flask-Cache==0.13.1
Flask-DebugToolbar==0.10.0     # En Django: django-debug-toolbar
Flask-fillin==0.2              # Diligenciar formularios en pruebas
Flask-Login==0.3.2
Flask-Migrate==1.8.0
Flask-Moment==0.5.1            # Integración con moment.js
Flask-OAuth==0.12              # ~ python-social-auth
Flask-Script==2.0.5            # manage.py, shell
Flask-SQLAlchemy==2.1
Flask-WTF==0.12                # Formularios con protección CSRF
WTForms-Alchemy==0.15.0        # Para crear formularios basados en modelos
WTForms-Components==0.10.0     # Campos adicionales para los formularios de Flask
{% endraw %}{% endcodeblock %}</p>

<p>{% img center /images/flask/nerd-dad.jpg %}</p>

<p>Gracias por su atención y a <a href="https://tappsi.co/">Tappsi</a> por el apoyo.</p>

<p>{% img center /images/flask/tappsi_logo.svg 100 %}</p>

<p>Estamos contratando <a href="&#x6d;&#97;&#105;&#108;&#116;&#111;&#x3a;&#x6a;&#x6f;&#98;&#115;&#64;&#x74;&#97;&#112;&#x70;&#x73;&#x69;&#46;&#x63;&#x6f;">&#106;&#111;&#x62;&#115;&#64;&#116;&#x61;&#x70;&#x70;&#115;&#105;&#x2e;&#99;&#111;</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Monitoreo de acciones de usuarios en Flask (SQLAlchemy)]]></title>
    <link href="http://blog.vero4ka.info/blog/2016/07/22/monitoreo-de-acciones-de-usuarios-en-flask-sqlalchemy/"/>
    <updated>2016-07-22T08:23:58-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2016/07/22/monitoreo-de-acciones-de-usuarios-en-flask-sqlalchemy</id>
    <content type="html"><![CDATA[<p>Suponemos que en nuestro proyecto de Flask hay un modelo <code>Client</code> definidao usando <a href="http://flask-sqlalchemy.pocoo.org/">Flask-SQLAlchemy</a> y queremos monetorear los cambios que se realizan sobre los objetos de ese modelo.</p>

<p>Para esto agregamos tres señales:</p>

<pre><code class="python models.py">from sqlalchemy import event

from main.signals import receive_before_update, receive_before_insert, receive_before_delete

class Client(db.Model):
    id = Column(Integer, primary_key=True)
    name = Column(String(255))
    email = Column(String(255), unique=True)
    phone = Column(String(255))

event.listen(Client, 'before_insert', receive_before_insert)
event.listen(Client, 'before_update', receive_before_update)
event.listen(Client, 'before_delete', receive_before_delete)
</code></pre>

<p>EN el gódigo de cada señal llamamos los métodos <code>inspect()</code> y <code>get_history()</code> para detectar los cambios sobre el objeto:</p>

<pre><code class="python">state = db.inspect(client_object)
for attr in state.attrs:
     hist = state.get_history(attr.key, True)
</code></pre>

<p>Por ejemplo, para el atributo <code>name</code>:</p>

<pre><code class="json">{
    'added': ['Company A'],
    'deleted': ['Company B'],
}
</code></pre>

<p>El mégoto <code>get_history()</code> nos devuelve un objeto <code>sqlalchemy.orm.attributes.History</code> que tiene los siguientes atributos:</p>

<ul>
<li><code>added</code> - listado de valores agregados al atributo de nuestro objeto</li>
<li><code>deleted</code> - listado de valores eliminados del atributo de nuestro objeto</li>
<li><code>unchanged</code> - listado de valores del atributo de nuestro objeto que se quedaron intactos</li>
<li><code>has_changes()</code> - método que retorna <code>True</code> si no habían ningunos cambios de valor de nuestro atributo.</li>
</ul>


<p>Ahora, usando la variable <code>current_user</code> de la biblioteca <a href="https://flask-login.readthedocs.io/">Flask-Login</a>, podemos guargar el usuario que realizó los cambios:</p>

<pre><code class="python signals.py">from flask_login import current_user

def save_changes(target, action):
    try:
        state = db.inspect(target)
        changes = {}
        for attr in state.attrs:
            hist = state.get_history(attr.key, True)
            if not hist.has_changes():
                continue
            added = format_changes_value(hist.added)
            deleted = format_changes_value(hist.deleted)
            if added != deleted:
                changes[attr.key] = {
                    'added': added,
                    'deleted': deleted,
                }
        if changes:
            mongo.db.user_logs.insert_one(dict(
                current_user_id=current_user.id,
                action=action,
                table_name=target.__tablename__,
                object_id=target.id,
                changes=changes,
                created_at=datetime.datetime.utcnow(),
            ))
    except Exception as e:
        pass

def receive_before_insert(mapper, connection, target):
    save_changes(target, 'create')


def receive_before_update(mapper, connection, target):
    save_changes(target, 'update')


def receive_before_delete(mapper, connection, target):
    save_changes(target, 'delete')
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SQL to SQLAlchemy conversions]]></title>
    <link href="http://blog.vero4ka.info/blog/2016/05/04/sql-to-sqlalchemy-conversions/"/>
    <updated>2016-05-04T21:15:39-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2016/05/04/sql-to-sqlalchemy-conversions</id>
    <content type="html"><![CDATA[<p>Some examples on how to convert raw SQL to SQLAlchemy query:</p>

<h3>Select all</h3>

<pre><code class="sql">SELECT COUNT(*)
</code></pre>

<pre><code class="python">&gt; from sqlalchemy import text, func
&gt; db.session.query(func.count()).all()
</code></pre>

<h3>Add labels</h3>

<pre><code class="sql">SELECT COUNT(*) as requiests
</code></pre>

<pre><code class="python">&gt; rows = db.session.query(func.count().label('requests')).all()
&gt; row = rows[0]
&gt; row.requests
12
</code></pre>

<h3>Sum</h3>

<pre><code class="sql">SELECT SUM(status) as rides
</code></pre>

<pre><code class="python">&gt; rows = db.session.query(func.sum(Book.status).label('books')).all()
&gt; row = rows[0]
&gt; row.books
12
</code></pre>

<h3>Return a count of rows and distinct</h3>

<pre><code class="sql">SELECT COUNT(DISTINCT(author_id)) as authors
</code></pre>

<pre><code class="python">from sqlalchemy import distinct
&gt; rows = db.session.query(
    func.count(distinct(Book.author_id)).label('authors')
).all()
</code></pre>

<h3>Query a date range</h3>

<pre><code class="sql">SELECT * FROM b WHERE b.created_at &gt; current_timestamp - (current_timestamp - interval '5 hours')::time
</code></pre>

<pre><code class="python">&gt; now = datetime.datetime.utcnow()
&gt; db.session.query(Book).filter(
    Book.created_at.between(now - datetime.timedelta(hours=5), now)
).all()
</code></pre>

<h3>Conditional sum</h3>

<pre><code class="sql">SELECT SUM(((status IN (4, 7))::int)) as books ...
</code></pre>

<pre><code class="python">&gt; from sqlalchemy.sql.expression import case
&gt; db.session.query(
    func.sum(case([(Book.status.in_((4, 7)), 1)], else_=0)).label('books'),
).filter(
    # ...
).all()
</code></pre>

<h3>In</h3>

<pre><code class="python">&gt; Book.query.filter(
    Book.status.in_((
        BOOK_CONFIRMED,
        BOOK_FINISHED,
    )),
).count()
</code></pre>

<h3>Other examples</h3>

<pre><code class="python">today = datetime.datetime.utcnow().date()
six_months_ago = today - relativedelta(months=6)

books = db.session.query(
    func.to_char(Book.created_at, 'MM'),
    func.count(Book.created_at)
).filter(
    Book.author_id == author.id,  # Filter books by author
).filter(
    Book.created_at.between(six_months_ago_min, today_max)  # Get all books created in last six months
).group_by(
    func.to_char(Book.created_at, 'MM')
).order_by(func.to_char(Book.created_at, 'MM')).all()
</code></pre>
]]></content>
  </entry>
  
</feed>
