<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: tdd | Cansada de ser feliz]]></title>
  <link href="http://blog.vero4ka.info/blog/categories/tdd/atom.xml" rel="self"/>
  <link href="http://blog.vero4ka.info/"/>
  <updated>2017-03-06T21:55:07-05:00</updated>
  <id>http://blog.vero4ka.info/</id>
  <author>
    <name><![CDATA[vero4ka]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Pruebas para formularios en Django]]></title>
    <link href="http://blog.vero4ka.info/blog/2015/09/30/pruebas-para-formularios-en-django/"/>
    <updated>2015-09-30T04:49:19-05:00</updated>
    <id>http://blog.vero4ka.info/blog/2015/09/30/pruebas-para-formularios-en-django</id>
    <content type="html"><![CDATA[<p>En esta entrada de blog quiero compartir la forma en la que escribo ruebas para formularios en un proyecto de Django.</p>

<p>Primero vamos a instalar los paquetes necesarios:</p>

<p>{% codeblock %}
$ pip install django-webtest
$ pip install factory-boy
{% endcodeblock %}</p>

<p><a href="http://webtest.pythonpaste.org/en/latest/WebTest">WebTest</a> es una biblioteca que nos ayuda a escribir pruebas para las aplicaciones wsgi. Es mucho más poderosa comparando con <code>django.test.Client</code> que viene con Django.</p>

<p>En el archivo de configuración especificamos que vamos a usar la base de datos SQLite para correr nuestras pruebas:</p>

<p>{% codeblock test_settings.py lang:python %}
DATABASES = {
    &lsquo;default&rsquo;: {
        &lsquo;ENGINE&rsquo;: &lsquo;django.db.backends.sqlite3&rsquo;,
    }
}
{% endcodeblock %}</p>

<p>Suponemos que queremos escribir una prueba unitaria para una vista que crea un objeto del modelo <code>Event</code>:</p>

<p>{% codeblock models.py lang:python %}
class Event(models.Model):
    title = models.CharField(max_length=500)
    start_date = models.DateTimeField()
    end_date = models.DateTimeField(blank=True, null=True)
    people = models.ManyToManyField(&lsquo;history.Person&rsquo;, blank=True, related_name=&lsquo;events&rsquo;)</p>

<p>class Person(models.Model):
    name = models.CharField(max_length=255)
{% endcodeblock %}</p>

<p>Aquí está la vista que maneja el formulario para crear un evento:</p>

<p>{% codeblock views.py lang:python %}</p>

<p>class EventCreateView(LoginRequiredMixin, CreateView):
    model = Event
    form_class = EventForm
    success_url = reverse_lazy(&lsquo;history:timeline&rsquo;)
{% endcodeblock %}</p>

<p>Ahora escribimos nuestra prueba. Vamos a extender la clase <code>django_webtest.WebTest</code>, que en su lugar extiende <code>django.test.TestCase</code> de Django, y crear a un usuario:</p>

<p>{% codeblock tests.py lang:python %}
from django_webtest import WebTest</p>

<p>class HistoryViewsTests(WebTest):
    def setUp(self):
        self.superuser = get_user_model().objects.create_superuser(
            email=&lsquo;<a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#x73;&#117;&#x70;&#x65;&#x72;&#x75;&#115;&#101;&#x72;&#64;&#x65;&#120;&#97;&#x6d;&#112;&#108;&#101;&#x2e;&#x63;&#111;&#x6d;">&#x73;&#117;&#x70;&#101;&#x72;&#x75;&#x73;&#101;&#114;&#64;&#x65;&#120;&#x61;&#109;&#x70;&#108;&#x65;&#x2e;&#99;&#x6f;&#109;</a>&rsquo;,
            username=&lsquo;superuser&rsquo;,
            password=&lsquo;secret&rsquo;,
        )
        super(HistoryViewsTests, self).setUp()</p>

<pre><code>def test_create_event(self):
    # código para nuestra prueba
</code></pre>

<p>{% endcodeblock %}</p>

<p>Ahora podemos probar que cuando un usuario trata de acceder nuestra página, se redirige al formulario de acceso (el códigos de estado HTTP es 302):</p>

<p>{% codeblock lang:python %}
url = reverse(&lsquo;history:event_create&rsquo;)
self.app.get(url, status=302)
{% endcodeblock %}</p>

<p>Ahora vamos a acceder la vista como superusuario:</p>

<p>{% codeblock lang:python %}
response = self.app.get(url, user=self.superuser, status=200)
{% endcodeblock %}</p>

<p>Como tenemos solo un formulario en la página, podemos obtenerlo por una de tres formas: por el atributo <code>.form</code>: <code>response.form</code>, por índice <code>response.forms[0]</code> o por <code>id</code> del formulario (artibuto HTML)<code>response.forms['event_form']</code>.</p>

<p>Para facilitar la depuración de nuestras pruebas, podemos pedir a mostrar el <code>response</code> en navegador predeterminado:</p>

<p>{% codeblock lang:python %}
response.showbrowser()
{% endcodeblock %}</p>

<p>Ahora podemos diligenciar nuestro formulario con los datos de prueba:</p>

<p>{% codeblock tests.py lang:python %}
class HistoryViewsTests(WebTest):
    # &hellip;</p>

<pre><code>def test_create_event(self):
    person1, person2, person3 = PersonFactory.create_batch(3)
    response = self.app.get(url, user=self.superuser, status=200)

    self.assertFalse(Event.objects.exists())

    form = response.forms['event_form']
    form['title'] = u'Título del evento'
    form['start_date'] = datetime.datetime.now()
    form['people'] = [person1.id, person2.id]
    form.submit().follow()

    self.assertEqual(Event.objects.count(), 1)

    event = Event.objects.first()
    self.assertEqual(event.title, u'Título del evento')

    people = event.people.all()
    self.assertIn(person1, people)
    self.assertIn(person2, people)
    self.assertNotIn(person3, people)
</code></pre>

<p>{% endcodeblock %}</p>

<p>Para generar objetos del modelo <code>Person</code> usamos la biblioteca <a href="http://factoryboy.readthedocs.org/">Factory Boy</a>:</p>

<p>{% codeblock factories.py lang:python %}
from ..models import Person</p>

<p>import factory
import factory.fuzzy</p>

<p>class PersonFactory(factory.django.DjangoModelFactory):
    name = factory.fuzzy.FuzzyText(length=50)</p>

<pre><code>class Meta:
    model = Person
</code></pre>

<p>{% endcodeblock %}</p>

<p>Así podemos acceder los opciones de una selección o selección múltiple:</p>

<p>{% codeblock lang:pycon %}</p>

<blockquote><blockquote><blockquote><p>print form[&lsquo;people&rsquo;].options
[(u'1', False, u'GLUZLvZfyjdZEmjNtnAJvsIVljodQjZpzLRDKrqJtYGiDLmSrN'), (u'2', False, u'vOxDBbmLaUXxJkJzcqYgLQpBieSoLtXJcpHCEPUpYUIzybhsAh'), (u'3', False, u'tfXSXCTIQICDwVPYvxZGSXgclFTnHbeYSQaMntxJNcgUJjzAwX')]
form[&lsquo;people&rsquo;] = [person1.id, person2.id]
print form[&lsquo;people&rsquo;].value
[u'1', u'2']
{% endcodeblock %}</p></blockquote></blockquote></blockquote>

<p>Ahora corremos nuestras pruebas y voilà:</p>

<p>{% codeblock %}
$ ./manage.py test
Creating test database for alias &lsquo;default&rsquo;&hellip;</p>

<h2>..</h2>

<p>Ran 1 test in 0.463s</p>

<p>OK
Destroying test database for alias &lsquo;default&rsquo;&hellip;
{% endcodeblock %}</p>

<p>Enlaces:</p>

<ul>
<li><a href="https://github.com/django-webtest/django-webtest">WebTest</a></li>
<li><a href="http://webtest.pythonpaste.org/en/latest/forms.html">Manejo de formularios con WebTest</a></li>
<li><a href="http://factoryboy.readthedocs.org/">Factory Boy</a></li>
</ul>

]]></content>
  </entry>
  
</feed>
